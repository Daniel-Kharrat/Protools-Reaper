in_pin:Left in
in_pin:Right in
out_pin:Left out
out_pin:Right out

slider1: 1<0,1,1{Unlinked,Linked}>Link L/R Delay
slider2: 0<0,500,1>Left Delay (ms)
slider3: 0<0,1,1{Normal,Inverted}>Left Polarity (Φ)
slider4: 0<0,500,1>Right Delay (ms)
slider5: 0<0,1,1{Normal,Inverted}>Right Polarity (Φ)

@init
max_delay_ms = 500;
max_delay_samples = ceil(srate * max_delay_ms / 1000);

// Use one contiguous buffer with explicit offsets
bufL = 0;
bufR = bufL + max_delay_samples;

buffer_pos = 0;

@slider
link_mode = slider1;

// In linked mode, right follows left
link_mode == 1 ? (
  slider4 = slider2;
  slider5 = slider3;
);

delay_L_ms = slider2;
delay_R_ms = slider4;

// integer sample counts
delay_samples_L = floor(min(delay_L_ms * srate / 1000, max_delay_samples - 1));
delay_samples_R = floor(min(delay_R_ms * srate / 1000, max_delay_samples - 1));

// Polarity flags
polarity_L = slider3 == 0 ? 1 : -1;
polarity_R = slider5 == 0 ? 1 : -1;

@sample
inL = spl0;
inR = spl1;

// write inputs
buf[bufL + buffer_pos] = inL;
buf[bufR + buffer_pos] = inR;

// read positions
read_pos_L = buffer_pos - delay_samples_L; read_pos_L < 0 ? read_pos_L += max_delay_samples;
read_pos_R = buffer_pos - delay_samples_R; read_pos_R < 0 ? read_pos_R += max_delay_samples;

// outputs: pure delayed (utility), strict L->L and R->R
spl0 = polarity_L * buf[bufL + read_pos_L];
spl1 = polarity_R * buf[bufR + read_pos_R];

// advance ring buffer
buffer_pos += 1;
buffer_pos >= max_delay_samples ? buffer_pos = 0;
